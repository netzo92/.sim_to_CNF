# To unbundle, sh this file
echo atpg.h 1>&2
cat >atpg.h <<'End of atpg.h'
/**********************************************************************/
/*           automatic test pattern generation                        */
/*           global data structures header file                       */
/*                                                                    */
/*           Author: Tony Hi Keung Ma                                 */
/*           last update : 09/28/1987                                 */
/**********************************************************************/


typedef struct WIRE *wptr;
typedef struct NODE *nptr;

struct WIRE {
    char *name;            /* asciz name of wire */
    nptr *inode;           /* nodes driving this wire */
    nptr *onode;           /* nodes driven by this wire */
    short nin;             /* number of input nodes */
    short nout;            /* number of output nodes */
    int value;             /* logic value of the wire */
    int flag;              /* flag word */
    wptr pnext;            /* general usage link */
    wptr hnext;            /* hash bucket link */
    /* data structure for podem test pattern generation */
    int level;             /* level of the wire */
    short *pi_reach;       /* array of no. of paths reachable from each pi */
    /* data structure for parallel fault simulator */
    int wire_value1;       /* fault-free value */
    int wire_value2;       /* faulty value */
    int fault_flag;        /* flag to indicate fault-injected bit */
    int wlist_index;       /* index into the wlist array */
};

struct NODE {
    char *name;            /* asciz name of node */
    wptr *iwire;           /* wires driving this node */
    wptr *owire;           /* wires driven by this node */
    short nin;             /* number of input wires */
    short nout;            /* number of output wires */
    int type;              /* node type */
    int flag;              /* flag word */
    nptr pnext;            /* general usage link */
    nptr hnext;            /* hash bucket link */
};

#define HASHSIZE 3911

/* types of gate */
#define NOT       1
#define NAND      2
#define AND       3
#define INPUT     4
#define NOR       5
#define OR        6
#define OUTPUT    8
#define XOR      11
#define BUF      17
#define EQV	      0	/* XNOR gate */
#define SCVCC    20

/* possible value for wire flag */
#define SCHEDULED       1
#define ALL_ASSIGNED    2
/*#define INPUT         4*/
/*#define OUTPUT        8*/
#define MARKED         16
#define FAULT_INJECTED 32
#define FAULTY         64
#define CHANGED       128
#define FICTITIOUS    256
#define PSTATE       1024
End of atpg.h
echo display.c 1>&2
cat >display.c <<'End of display.c'
#include <stdio.h>
#include "global.h"
#include "miscell.h"

#define U  2
#define D  3
#define B  4

extern char *filename;

display_line(fault)
fptr fault;
{
    register int i;
    char unpack();

    for (i = 0; i < ncktin; i++) {
	      switch (cktin[i]->value) {
	          case 0: fprintf(stdout,"0"); break;
	          case 1: fprintf(stdout,"1"); break;
	          case U: fprintf(stdout,"x"); break;
	          case D: fprintf(stdout,"D"); break;
	          case B: fprintf(stdout,"B"); break;
        }
    }
	  fprintf(stdout," ");
	  for (i = 0 ; i < fault->node->nin; i++) {
		 fprintf(stdout,"%s = ",fault->node->iwire[i]->name);
	      switch (fault->node->iwire[i]->value) {
	          case 0: fprintf(stdout,"0"); break;
	          case 1: fprintf(stdout,"1"); break;
	          case U: fprintf(stdout,"x"); break;
	          case D: fprintf(stdout,"D"); break;
	          case B: fprintf(stdout,"B"); break;
        }
	      fprintf(stdout,"; ");
    }
    fprintf(stdout,"output = ");
	  switch (fault->node->owire[0]->value) {
	      case 0: fprintf(stdout,"0"); break;
	      case 1: fprintf(stdout,"1"); break;
	      case U: fprintf(stdout,"x"); break;
	      case D: fprintf(stdout,"D"); break;
	      case B: fprintf(stdout,"B"); break;
    }
    fprintf(stdout,"\n");
    return;
}/* end of display_line */


/*
* print primary input and output lines' values
*/
display_io()
{
    register int i;
    char unpack();

    for (i = 0; i < ncktin; i++) {
	      switch (cktin[i]->value) {
	          case 0: fprintf(stdout,"0"); break;
	          case 1: fprintf(stdout,"1"); break;
	          case U: fprintf(stdout,"x"); break;
	          case D: fprintf(stdout,"1"); break;
	          case B: fprintf(stdout,"0"); break;
        }
    }
	fprintf(stdout," ");
    for (i = 0; i < ncktout; i++) {
	      switch (cktout[i]->value) {
	          case 0: fprintf(stdout,"0"); break;
	          case 1: fprintf(stdout,"1"); break;
	          case U: fprintf(stdout,"x"); break;
	          case D: fprintf(stdout,"D"); break;
	          case B: fprintf(stdout,"B"); break;
        }
    }
    fprintf(stdout,"\n");
    return;
}/* end of display_io */


display_undetect(undetect_fault)
fptr undetect_fault;
{
    register int i;
    register fptr f;
    register wptr w;
    FILE *out,*fopen();
	char ufile[40];

	sprintf(ufile,"%s.uf",filename); 
    out = fopen(ufile,"w");
    for (f = undetect_fault; f; f = f->pnext_undetect) {
        switch (f->node->type) {
            case INPUT:
                fprintf(out,"primary input: %s\n",f->node->owire[0]->name);
		break;
            case OUTPUT:
                fprintf(out,"primary output: %s\n",f->node->iwire[0]->name);
		break;
            default:
                fprintf(out,"gate: %s ;",f->node->name);
                if (f->io == GI) {
                    fprintf(out,"input wire name: %s\n",f->node->iwire[f->index]->name);
                }
                else {
                    fprintf(out,"output wire name: %s\n",f->node->owire[0]->name);
                }
	        break;
        }
        fprintf(out,"fault_type = ");
	switch (f->fault_type) {
	    case STUCK0:
		fprintf(out,"s-a-0\n"); break;
	    case STUCK1:
		fprintf(out,"s-a-1\n"); break;
	}
        fprintf(out,"detection flag =");
        switch (f->detect) {
            case FALSE:
                fprintf(out," aborted\n");
                break;
            case REDUNDANT:
                fprintf(out," redundant\n");
                break;
            case TRUE:
                fprintf(out," internal error\n");
                break;
        }
		fprintf(out,"fault no. = %d\n", f->fault_no);
        /*if (f->io) w = f->node->owire[0];
        else w = f->node->iwire[f->index];
        for (i = 0; i < ncktin; i++) {
            fprintf(out,"%d ",w->pi_reach[i]);
        }
        fprintf(out,"\n");*/
        fprintf(out,"\n");
    }
    fclose(out);
    return;
}/* end of display_undetect */


void
display_fault(f)
fptr f;
{
    register int i;
    register wptr w;

    switch (f->node->type) {
        case INPUT:
            fprintf(stdout,"primary input: %s\n",f->node->owire[0]->name);
			break;
        case OUTPUT:
            fprintf(stdout,"primary output: %s\n",f->node->iwire[0]->name);
		    break;
        default:
            fprintf(stdout,"gate: %s ;",f->node->name);
            if (f->io == GI) {
                fprintf(stdout,"input wire name: %s\n",f->node->iwire[f->index]->name);
            }
            else {
                fprintf(stdout,"output wire name: %s\n",f->node->owire[0]->name);
            }
	        break;
	}
    fprintf(stdout,"fault_type = ");
	switch (f->fault_type) {
	    case STUCK0:
		    fprintf(stdout,"s-a-0\n"); break;
	    case STUCK1:
		    fprintf(stdout,"s-a-1\n"); break;
	}
    fprintf(stdout,"detection flag =");
    switch (f->detect) {
        case FALSE:
            fprintf(stdout," aborted\n");
            break;
        case REDUNDANT:
            fprintf(stdout," redundant\n");
            break;
        case TRUE:
            fprintf(stdout," internal error\n");
            break;
    }
    fprintf(stdout,"\n");
}/* end of display_fault */
End of display.c
echo global.h 1>&2
cat >global.h <<'End of global.h'
/**********************************************************************/
/*           automatic test pattern generation                        */
/*           global variables shared by all programs                  */
/*                                                                    */
/*           Author: Hi-Keung Tony Ma                                 */
/*           last update : 5/12/1986                                  */
/**********************************************************************/

#include"atpg.h"

#ifdef MAIN

wptr *sort_wlist;          /* sorted wire list with regard to level */
wptr *cktin;               /* input wire list */
wptr *cktout;              /* output wire list */
wptr hash_wlist[HASHSIZE]; /* hashed wire list */
nptr hash_nlist[HASHSIZE]; /* hashed node list */
int ncktwire;              /* total number of wires in the circuit */
int ncktnode;              /* total number of nodes in the circuit */
int ncktin;                /* number of primary inputs */
int ncktout;               /* number of primary outputs */
int in_vector_no;          /* number of test vectors generated */

#else

extern wptr *sort_wlist;          /* sorted wire list with regard to level */
extern wptr *cktin;               /* input wire list */
extern wptr *cktout;              /* output wire list */
extern wptr hash_wlist[HASHSIZE]; /* hashed wire list */
extern nptr hash_nlist[HASHSIZE]; /* hashed node list */
extern int ncktwire;              /* total number of wires in the circuit */
extern int ncktnode;              /* total number of nodes in the circuit */
extern int ncktin;                /* number of primary inputs */
extern int ncktout;               /* number of primary outputs */
extern int in_vector_no;          /* number of test vectors generated */

#endif
End of global.h
echo init_flist.c 1>&2
cat >init_flist.c <<'End of init_flist.c'
/**********************************************************************/
/*           routines building the dummy input and output gate list;  */
/*           building the fault list;                                 */
/*           calculating the total fault coverage.                    */
/*                                                                    */
/*           Author: Hi-Keung Tony Ma                                 */
/*           last update : 10/29/1987                                 */
/**********************************************************************/

#include <stdio.h>
#include "global.h"
#include "miscell.h"

int num_of_gate_fault;
extern int debug;

generate_fault_list()
{
	int i,j,k;
	wptr w;
	nptr n;
	fptr f;
	int fault_num;

	first_fault = NIL(struct FAULT);
	num_of_gate_fault = 0;

	for (i = ncktwire - 1; i >= 0; i--) {
	/*for (i = 0; i < ncktwire; i++) {*/
		w = sort_wlist[i];
		n = w->inode[0];
		if (!(f = ALLOC(1,struct FAULT))) error("No more room!");
		f->node = n;
		f->io = GO;
		f->fault_type = STUCK0;
		f->to_swlist = i;
		switch (n->type) {
			case   AND:
			case   NOR:
			case   NOT:
			case   BUF:
				f->eqv_fault_num = 1;
				for (j = 0; j < w->inode[0]->nin; j++) {
					if (w->inode[0]->iwire[j]->nout > 1) f->eqv_fault_num++;
				}
				break;
			case INPUT:
			case    OR:
			case  NAND: 
			case   EQV:
			case   XOR: f->eqv_fault_num = 1; break;
		}
		num_of_gate_fault += f->eqv_fault_num;
		f->pnext = first_fault;
		f->pnext_undetect = first_fault;
		first_fault = f;
		if (!(f = ALLOC(1,struct FAULT))) error("No more room!");
		f->node = n;
		f->io = GO;
		f->fault_type = STUCK1;
		f->to_swlist = i;
		switch (n->type) {
			case    OR:
			case  NAND:
			case   NOT:
			case   BUF:
				f->eqv_fault_num = 1;
				for (j = 0; j < w->inode[0]->nin; j++) {
					if (w->inode[0]->iwire[j]->nout > 1) f->eqv_fault_num++;
				}
				break;
			case INPUT:
			case   AND:
			case   NOR: 
			case   EQV:
			case   XOR: f->eqv_fault_num = 1; break;
		}
		num_of_gate_fault += f->eqv_fault_num;
		f->pnext = first_fault;
		f->pnext_undetect = first_fault;
		first_fault = f;
		if (w->nout > 1) {
			for (j = 0 ; j < w->nout; j++) {
				n = w->onode[j];
				switch (n->type) {
					case OUTPUT:
					case    OR:
					case   NOR: 
					case   EQV:
					case   XOR:
						if (!(f = ALLOC(1,struct FAULT))) error("No more room!");
						f->node = n;
						f->io = GI;
						f->fault_type = STUCK0;
						f->to_swlist = i;
						f->eqv_fault_num = 1;
						for (k = 0; k < n->nin; k++) {
							if (n->iwire[k] == w) f->index = k;
						}
						num_of_gate_fault++;
						f->pnext = first_fault;
						f->pnext_undetect = first_fault;
						first_fault = f;
						break;
				}
				switch (n->type) {
					case OUTPUT:
					case   AND:
					case  NAND: 
					case   EQV:
					case   XOR:
						if (!(f = ALLOC(1,struct FAULT))) error("Room more room!");
						f->node = n;
						f->io = GI;
						f->fault_type = STUCK1;
						f->to_swlist = i;
						f->eqv_fault_num = 1;
						for (k = 0; k < n->nin; k++) {
							if (n->iwire[k] == w) f->index = k;
						}
						num_of_gate_fault++;
						f->pnext = first_fault;
						f->pnext_undetect = first_fault;
						first_fault = f;
						break;
				}
			}
		}
	}
	for (f = first_fault, fault_num = 0; f; f = f->pnext, fault_num++) {
		f->fault_no = fault_num;
	}
	fprintf(stdout,"#number of equivalent faults = %d\n", fault_num);
	return;  
}/* end of generate_fault_list */


/* computing the actual fault coverage */
compute_fault_coverage()
{
    register double gate_fault_coverage,eqv_gate_fault_coverage;
    register int no_of_detect,eqv_no_of_detect,eqv_num_of_gate_fault;
    register fptr f;

    debug = 0;
    no_of_detect = 0;
    gate_fault_coverage = 0;
    eqv_no_of_detect = 0;
    eqv_gate_fault_coverage = 0;
    eqv_num_of_gate_fault = 0;
    
    for (f = first_fault; f; f = f->pnext) {

        if (debug) {
			if (!f->detect) {
                switch (f->node->type) {
				   case INPUT:
                        fprintf(stdout,"primary input: %s\n",f->node->owire[0]->name);
					  break;
                    case OUTPUT:
                        fprintf(stdout,"primary output: %s\n",f->node->iwire[0]->name);
					  break;
                    default:
                        fprintf(stdout,"gate: %s ;",f->node->name);
                        if (f->io == GI) {
                            fprintf(stdout,"input wire name: %s\n",f->node->iwire[f->index]->name);
                        }
                        else {
                            fprintf(stdout,"output wire name: %s\n",f->node->owire[0]->name);
                        }
					  break;
                }
                fprintf(stdout,"fault_type = ");
			    switch (f->fault_type) {
				   case STUCK0:
					  fprintf(stdout,"s-a-0\n"); break;
				   case STUCK1:
					  fprintf(stdout,"s-a-1\n"); break;
			    }
                fprintf(stdout,"no of equivalent fault = %d\n",f->eqv_fault_num);
                fprintf(stdout,"detection flag = %d\n",f->detect);
                fprintf(stdout,"\n");
            }
        }

		 if (f->detect == TRUE) {
	          no_of_detect += f->eqv_fault_num;
			eqv_no_of_detect++;
	      }
	      eqv_num_of_gate_fault++;
    }
    if (num_of_gate_fault != 0) 
    gate_fault_coverage = (((double) no_of_detect) / num_of_gate_fault) * 100;
    if (eqv_num_of_gate_fault != 0) 
    eqv_gate_fault_coverage = (((double) eqv_no_of_detect) / eqv_num_of_gate_fault) * 100;
    
    /* print out fault coverage results */
    fprintf(stdout,"\n");
    fprintf(stdout,"#FAULT COVERAGE RESULTS :\n");
    fprintf(stdout,"#number of test vectors = %d\n",in_vector_no);
    fprintf(stdout,"#total number of gate faults = %d\n",num_of_gate_fault);
    fprintf(stdout,"#total number of detected faults = %d\n",no_of_detect);
    fprintf(stdout,"#total gate fault coverage = %5.2f%%\n",gate_fault_coverage);
    fprintf(stdout,"#number of equivalent gate faults = %d\n",eqv_num_of_gate_fault);
    fprintf(stdout,"#number of equivalent detected faults = %d\n",eqv_no_of_detect);
    fprintf(stdout,"#equivalent gate fault coverage = %5.2f%%\n",eqv_gate_fault_coverage);
    fprintf(stdout,"\n");
    return;  
}/* end of compute_fault_coverage */


create_dummy_gate()
{
    register int i,j;
    register int num_of_dummy;
    register nptr n,*n2;
    register char sgate[25];
    register char intstring[25];
    nptr getnode();

    num_of_dummy = 0;

    for (i = 0; i < ncktin; i++) {
	      num_of_dummy++;
		 itoa(num_of_dummy,intstring);
		 sprintf(sgate,"dummy_gate%s",intstring);
		 n = getnode(sgate);
		 n->nout = 1;
		 n->type = INPUT;
		 if (!(n->owire = ALLOC(1,wptr))) error("No more room!");
		 n->owire[0] = cktin[i];
		 if (!(cktin[i]->inode = ALLOC(1,nptr))) error("No more romm!");
		 cktin[i]->inode[0] = n;
		 cktin[i]->nin = 1;
    }

    for (i = 0; i < ncktout; i++) {
	      num_of_dummy++;
		 itoa(num_of_dummy,intstring);
		 sprintf(sgate,"dummy_gate%s",intstring);
		 n = getnode(sgate);
		 n->nin = 1;
		 n->type = OUTPUT;
		 if (!(n->iwire = ALLOC(1,wptr))) error("No more room!");
		 n->iwire[0] = cktout[i];
		 cktout[i]->nout++;
		 if (!(n2 = ALLOC(cktout[i]->nout,nptr))) error("No more room!");
		 n2[(cktout[i]->nout - 1)] = n;
        for (j = 0; j < (cktout[i]->nout - 1); j++) {
            n2[j] = cktout[i]->onode[j];
        }
		 if (cktout[i]->onode) free(cktout[i]->onode);
		 cktout[i]->onode = n2;
    }
    return;
}/* end of create_dummy_gate */


/*
*   The itoa function
*/

reverse(s)  /*  reverse string s in place */
char s[];
{
   int c,i,j;

   for(i=0,j = strlen(s) - 1;i<j;i++,j--) {
      c = s[i];
      s[i] = s[j];
      s[j] = c;
   }
}

itoa(n,s)   /*  convert n to characters in s */
int n;
char s[];
{
   int i,sign;

   if ((sign = n) < 0)  /* record sign */
     n = -n;
   i = 0;
   do {   /*  generate digits in reverse order */
        s[i++] = n % 10 + '0' ;  /* get next digit */
   } while ((n/=10) > 0); /* delete it */
   if (sign < 0)
     s[i++] = '-';
   s[i] = '\0';
   reverse(s);

}  /*   end of itoa  */


End of init_flist.c
echo input.c 1>&2
cat >input.c <<'End of input.c'
/**********************************************************************/
/*           This is the input processor for atpg                     */
/*                                                                    */
/*           Author: Tony Hi Keung Ma                                 */
/*           last update : 10/13/1987                                 */
/**********************************************************************/


#include <stdio.h>
#include "global.h"
#include "miscell.h"

#define LSIZE   500       /* line length */
#define NUM_OF_INPUT 300  /* maximum number of inputs */
#define NUM_OF_OUTPUT 300 /* maximum number of outputs */

int debug = 0;            /* != 0 if debugging */

char *filename;           /* current input file */
int lineno = 0;           /* current line number */
char *targv[100];        /* pointer to tokens on current command line */
int targc;                /* number of args on current command line */
int file_no = 0;         /* number of current file */
wptr *temp_cktin;        /* temporary input wire list */
wptr *temp_cktout;       /* temporary output wire list */

/* eq() routine checks the equivalence of two character strings
 * return TRUE if they are equal, otherwise return FALSE
*/
eq(string1,string2)
register char *string1,*string2;
{
    while(*string1 && *string2) {
        if(*string1++ != *string2++) return(FALSE);
    }
    if (!(*string2)) return(*string1 == '\0');
    return(*string2 == '\0');
}/* end of eq */


int
hashcode(name)
char *name;
{ 
    int i = 0;
    int j = 0;

    while (*name && j < 8) {
        i = i*10 + (*name++ - '0');
        j++;
    }
    i = i%HASHSIZE;
    return(i<0 ? i + HASHSIZE : i);
}/* end of hashcode */


/* nfind checks the existence of a node
 * return the node pointer if it exists; otherwise return a NULL pointer
 */
nptr
nfind(name)
char *name;
{ 
    nptr ntemp;

    for (ntemp = hash_nlist[hashcode(name)]; ntemp != 0; ntemp = ntemp->hnext) {
        if (eq(name,ntemp->name)) return(ntemp);
    }
    return(NULL);
}/* end of nfind */


/* wfind checks the existence of a wire
 * return the wire pointer if it exists; otherwise return a NULL pointer
 */
wptr
wfind(name)
char *name;
{
    wptr wtemp;

    for (wtemp = hash_wlist[hashcode(name)]; wtemp != 0; wtemp = wtemp->hnext) {
        if (eq(name,wtemp->name)) return(wtemp);
    }
    return(NULL);
}/* end of cfind */


/* get wire structure and return the wire pointer */
wptr
getwire(wirename)
char *wirename;
{
    wptr w;
    char *name;
    int hash_no;
    char *malloc();

    if (w = wfind(wirename)) return(w);

	/* allocate new wire from free storage */
	if (!(w = ALLOC(1,struct WIRE))) error("No more room!");
    ncktwire++;

    /* initialize wire entries */

    hash_no = hashcode(wirename);
    w->hnext = hash_wlist[hash_no];
    hash_wlist[hash_no] = w;
    w->pnext = NULL;
    w->name = name = malloc(strlen(wirename) + 1);
    while (*name++ = *wirename++);
    return(w);
}/* end of getwire */


/* get node structure and return the node pointer */
nptr getnode(nodename)
char *nodename;
{
    nptr n;
    char *name;
    int hash_no;
    char *malloc();
  
    if (n = nfind(nodename)) error("node defined twice");
  
    /* allocate new node from free storage */
    if (!(n = ALLOC(1,struct NODE))) error("No more room!");

    /* initialize node entries */

    hash_no = hashcode(nodename);
    n->hnext = hash_nlist[hash_no];
    hash_nlist[hash_no] = n;
    n->pnext = NULL;
    n->name = name = malloc(strlen(nodename) + 1);
    while (*name++ = *nodename++);
    return(n);
}/* end of getnode */

      
/* new gate */
newgate()
{
    nptr n;
    wptr w;
    int i;
    int iwire_index = 0;

    if ((targc < 5) || !(eq(targv[targc - 2],";")))
		error("Bad Gate Record");
    n = getnode(targv[0]);
    ncktnode++;
    n->type = FindType(targv[1]);
    n->nin = targc - 4;
    if (!(n->iwire = ALLOC(n->nin,wptr))) error("No More Room!");
    i = 2;
    while (i < targc) {
        if (eq(targv[i],";")) break;
        w = getwire(targv[i]); 
        n->iwire[iwire_index] = w;
        w->nout++;
        iwire_index++;
        i++;
    }
    if (i == 2 || ((i + 2) != targc)) error("Bad Gate Record");
    i++;
    w = getwire(targv[i]); 
    n->nout = 1;
    if (!(n->owire = ALLOC(1,wptr))) error("No More Room!");
    *n->owire = w;
    w->nin++;
    return;
}/* end of newgate */


set_output()
{
    wptr w;
    int i,j;
	void exit();

    for (i = 1; i < targc; i++) {
        w = getwire(targv[i]);
        for (j = 0; j < ncktout; j++) {
            if (w == temp_cktout[j]) {
                fprintf(stderr,"net %s is declared again as output around line %d\n",w->name,lineno);
                exit(-1);
            }
        }
        temp_cktout[ncktout] = w;
        ncktout++;
    }
    return;
}/* end of set_output */
      

set_input(pori)
int pori;
{
    wptr w;
    int i,j;
	void exit();

    for (i = 1; i < targc; i++) {
         w = getwire(targv[i]);
         for (j = 0; j < ncktin; j++) {
             if (w == temp_cktin[j]) {
                 fprintf(stderr,"net %s is declared again as input around line %d\n",w->name,lineno);
                exit(-1);
            }
        }
        temp_cktin[ncktin] = w;
        if (pori == 1) {
            temp_cktin[ncktin]->flag |= PSTATE;
        }
        ncktin++;
    }
    return;
}/* end of set_input */
      

/* parse input line into tokens, filling up targv and setting targc */
parse_line(line)
char *line;
{
    char **carg = targv;
    char ch;

    targc = 0;
    while (ch = *line++) {
        if (ch <= ' ') continue;
        targc++;
        *carg++ = line-1;
        while ((ch = *line) && ch > ' ') line++;
        if (ch) *line++ = '\0';
    }
    *carg = 0;
}/* end of parse_line */


void
input(infile)
char *infile;
{ 
    int i;
    char line[LSIZE];
    FILE *in;


    for (i = 0; i < HASHSIZE; i++) {
        hash_wlist[i] = NULL;
        hash_nlist[i] = NULL;
    }
    if (!(temp_cktin = ALLOC(NUM_OF_INPUT,wptr)))
		error("No More Room!");
    if (!(temp_cktout = ALLOC(NUM_OF_OUTPUT,wptr)))
		error("No More Room!");
    ncktin = 0;
    ncktout = 0;
    filename = infile;
    if ((in = fopen(infile,"r")) == NULL) {
        fprintf(stderr,"Cannot open input file %s\n",infile);
        exit(-1);
    }
    while (1) {
        if (fgets(line,LSIZE,in) != line) break;
        lineno++;
        parse_line(line);
        if (targv[0] == NULL) continue;
        if (eq(targv[0],"name")) {
            if (targc != 2) error("Wrong Input Format!");
			continue;
		}
        switch (targv[0][0]) {
            case '#':    break;

            case 'D': debug = 1 - debug; break;

            case 'g': newgate(); break;

            case 'i': set_input(0); break;

            case 'p': set_input(1); break;

            case 'o': set_output(); break;

            case 'n': set_output(); break;

            default:
                fprintf(stderr,"Unrecognized command around line %d in file %s\n",lineno,filename);
                 break;
        }
    }
    fclose(in);
    create_structure();
    fprintf(stdout,"\n");
    fprintf(stdout,"#Circuit Summary:\n");
    fprintf(stdout,"#---------------\n");
    fprintf(stdout,"#number of inputs = %d\n",ncktin);
    fprintf(stdout,"#number of outputs = %d\n",ncktout);
    fprintf(stdout,"#number of gates = %d\n",ncktnode);
    fprintf(stdout,"#number of wires = %d\n",ncktwire);
    if (debug) display_circuit();
}/* end of input */


create_structure()
{
    wptr w;
    nptr n;
    int i, j, k;

    if (!(cktin = ALLOC(ncktin,wptr))) error("No More Room!");
    if (!(cktout = ALLOC(ncktout,wptr))) error("No More Room!");
    for (i = 0; i < ncktin; i++) {
        cktin[i] = temp_cktin[i];
        cktin[i]->flag |= INPUT;
    }
    cfree(temp_cktin);
    for (i = 0; i < ncktout; i++) {
        cktout[i] = temp_cktout[i];
        cktout[i]->flag |= OUTPUT;
    }
    cfree(temp_cktout);

    for (i = 0; i < HASHSIZE; i++) {
        for (w = hash_wlist[i]; w; w = w->hnext) {
			if (w->nin > 0)
            	if (!(w->inode = ALLOC(w->nin,nptr)))
					error("No More Room!");
			if (w->nout > 0)
            	if (!(w->onode = ALLOC(w->nout,nptr)))
					error("No More Room!");
        }
    }
    for (i = 0; i < HASHSIZE; i++) {
        for (n = hash_nlist[i]; n; n = n->hnext) {
            for (j = 0; j < n->nin; j++) {
                for (k = 0; n->iwire[j]->onode[k]; k++);
                n->iwire[j]->onode[k] = n;
            }
            for (j = 0; j < n->nout; j++) {
                for (k = 0; n->owire[j]->inode[k]; k++);
                n->owire[j]->inode[k] = n;
            }
        }
    }
    return;
}/* end of create_structure */


FindType(gatetype)
char *gatetype;
{
    if (!(strcmp(gatetype,"and"))) return(AND);
    if (!(strcmp(gatetype,"nand"))) return(NAND);
    if (!(strcmp(gatetype,"or"))) return(OR);
    if (!(strcmp(gatetype,"nor"))) return(NOR);
    if (!(strcmp(gatetype,"not"))) {
        if (targc != 5) error("Bad Gate Record");
        return(NOT);
    }
    if (!(strcmp(gatetype,"buf"))) {
        if (targc != 5) error("Bad Gate Record");
        return(BUF);
    }
    if (!(strcmp(gatetype,"xor"))) {
        if (targc != 6) error("Bad Gate Record");
        return(XOR);
    }
    if (!(strcmp(gatetype,"eqv"))) {
        if (targc != 6) error("Bad Gate Record");
        return(EQV);
    }
    error("unreconizable gate type");
}/* end of FindType */


/*
* print error message and die
*/
error(message)
char *message;
{
    fprintf(stderr,"%s around line %d in file %s\n",message,lineno,filename);
    exit(0);
}/* end of error */


/*
* get the elapsed cputime
* (call it the first time with message "START")
*/ 
struct tbuffer {
    long utime;
    long stime;
    long cutime;
    long cstime;
} Buffer;

double StartTime, LastTime;

timer(file,mesg1,mesg2)
FILE *file;
char *mesg1,*mesg2;
{
    long junk;
    if(strcmp(mesg1,"START") == 0) {
        junk = times(&Buffer);
        StartTime = (double)(Buffer.utime);
        LastTime = StartTime;
        return;
    }
    junk = times(&Buffer);
    fprintf(file,"#atpg: cputime %s %s: %.1fs %.1fs\n", mesg1,mesg2,
         (Buffer.utime-LastTime)/60.0, (Buffer.utime-StartTime)/60.0);
    LastTime = Buffer.utime;
    return;
}/* end of timer */

display_circuit()
{
    register nptr n;
    register wptr w;
    register int i,j;

    fprintf(stdout,"\n");
    for (i = 0; i < HASHSIZE; i++) {
          for (n = hash_nlist[i]; n; n = n->hnext) {
             fprintf(stdout,"%s ",n->name);
             switch(n->type) {
                case AND :
                   fprintf(stdout,"and ");
                   break;
                case NAND :
                   fprintf(stdout,"nand ");
                   break;
                case OR :
                   fprintf(stdout,"or ");
                   break;
                case NOR :
                   fprintf(stdout,"nor ");
                   break;
                case BUF :
                   fprintf(stdout,"buf ");
                   break;
                case NOT :
                   fprintf(stdout,"not ");
                   break;
                case XOR :
                   fprintf(stdout,"xor ");
                   break;
                case EQV :
                   fprintf(stdout,"eqv ");
                   break;
            }
            for (j = 0; j < n->nin; j++) {
                fprintf(stdout,"%s ",n->iwire[j]->name);
            }
            fprintf(stdout,"; ");
            for (j = 0; j < n->nout; j++) {
                fprintf(stdout,"%s\n",n->owire[j]->name);
            }
        }
    }
    fprintf(stdout,"i ");
    for (i = 0 ; i < ncktin; i++) {
          fprintf(stdout,"%s ",cktin[i]->name);
      }
    fprintf(stdout,"\n");
    fprintf(stdout,"o ");
    for (i = 0 ; i < ncktout; i++) {
          fprintf(stdout,"%s ",cktout[i]->name);
      }
    fprintf(stdout,"\n");

    fprintf(stdout,"\n");
    for (i = 0; i < HASHSIZE; i++) {
          for (w = hash_wlist[i]; w; w = w->hnext) {
            fprintf(stdout,"%s ",w->name);
            for (j = 0; j < w->nin; j++) {
                fprintf(stdout,"%s ",w->inode[j]->name);
             }
            fprintf(stdout,";");
            for (j = 0; j < w->nout; j++) {
                fprintf(stdout,"%s ",w->onode[j]->name);
             }
            fprintf(stdout,"\n");
          }
    }
    return;
} /* end of display_circuit */
End of input.c
echo level.c 1>&2
cat >level.c <<'End of level.c'
/**********************************************************************/
/*           This is the levelling routine for atpg                   */
/*                                                                    */
/*           Author: Tony Hi-Keung Ma                                 */
/*           last update : 1/27/1987                                  */
/**********************************************************************/


#include <stdio.h>
#include "global.h"
#include "miscell.h"


void
level_circuit()
{
    register wptr w,wfirst,wtemp;
    register nptr nfirst,nlast,ncurrent,nprelast;
    register int wire_index,i,j,k;
    register int schedule,level = 0;

    nfirst = NIL(struct NODE);
    nlast = NIL(struct NODE);
    wfirst = NIL(struct WIRE);
    sort_wlist = ALLOC(ncktwire,wptr);

    /* build up the initial node event list */
    for (wire_index = 0; wire_index < ncktin; wire_index++) {
        sort_wlist[wire_index] = cktin[wire_index];
        cktin[wire_index]->wlist_index = wire_index;
        cktin[wire_index]->flag |= MARKED;
        cktin[wire_index]->level = level;
        for (i = 0; i < cktin[wire_index]->nout; i++) {
            if (!(cktin[wire_index]->onode[i]->pnext) &&
                cktin[wire_index]->onode[i] != nlast) {
                cktin[wire_index]->onode[i]->pnext = nfirst;
                nfirst = cktin[wire_index]->onode[i];
            }
            if (!nlast) nlast = nfirst;
        }
    }
    nprelast = nlast;

    while(nfirst) {
        ncurrent = nfirst;
        nfirst = nfirst->pnext;
        ncurrent->pnext = NIL(struct NODE);
        schedule = TRUE;
        for (i = 0; i < ncurrent->nin; i++) {
            if (!(ncurrent->iwire[i]->flag & MARKED)) {
                schedule = FALSE;
            }
        }
        if (schedule) {
            for (j = 0; j < ncurrent->nout; j++) {
                sort_wlist[wire_index] = ncurrent->owire[j];
                ncurrent->owire[j]->wlist_index = wire_index;
                wire_index++;
                ncurrent->owire[j]->pnext = wfirst;
                wfirst = ncurrent->owire[j];
                for (k = 0; k < ncurrent->owire[j]->nout; k++) {
                    if (!(ncurrent->owire[j]->onode[k]->pnext) &&
                        ncurrent->owire[j]->onode[k] != nlast) {
                        nlast->pnext = ncurrent->owire[j]->onode[k];
                        nlast = ncurrent->owire[j]->onode[k];
                        if (!nfirst) nfirst = nlast;
                    }
                }
            }
        }
        else {
            if (!(ncurrent->pnext) && ncurrent != nlast) {
                nlast->pnext = ncurrent;
                nlast = ncurrent;
            }
            if (!nfirst) nfirst = nlast;
        }
        if (ncurrent == nprelast) {
            level++;
            for (w = wfirst; w; w = wtemp) {
                wtemp = w->pnext;
                w->pnext = NIL(struct WIRE);
                w->flag |= MARKED;
                w->level = level;
            }
            wfirst = NIL(struct WIRE);
            nprelast = nlast;
        }
    }
    /* unmark each wire */
    for (i = 0; i < ncktwire; i++) {
        sort_wlist[i]->flag &= ~MARKED;
    }
}/* end of level */


void
rearrange_gate_inputs()
{
    register int i,j,k;
    register wptr wtemp;
    register nptr n;

    for (i = ncktin; i < ncktwire; i++) {
        if (n = sort_wlist[i]->inode[0]) {
            for (j = 0; j < n->nin; j++) {
                for (k = j + 1; k < n->nin; k++) {
                    if (n->iwire[j]->level > n->iwire[k]->level) {
                        wtemp = n->iwire[j];
                        n->iwire[j] = n->iwire[k];
                        n->iwire[k] = wtemp;
                    }
                }
            }
        }
    }
}/* end of rearrange_gate_inputs */
End of level.c
echo logic_tbl.h 1>&2
cat >logic_tbl.h <<'End of logic_tbl.h'
#define MULTIVALUE 5
#define U  2
#define D  3
#define B  4

int ANDTABLE[MULTIVALUE][MULTIVALUE] =  { 0,  0,  0,  0,  0,
								     0,  1,  U,  D,  B,
                                          0,  U,  U,  U,  U,
								     0,  D,  U,  D,  0,
                                          0,  B,  U,  0,  B };

int ORTABLE[MULTIVALUE][MULTIVALUE]  =  { 0,  1,  U,  D,  B,
								     1,  1,  1,  1,  1,
								     U,  1,  U,  U,  U,
								     D,  1,  U,  D,  1,
								     B,  1,  U,  1,  B };

int XORTABLE[MULTIVALUE][MULTIVALUE] =  { 0,  1,  U,  D,  B,
								     1,  0,  U,  B,  D,
								     U,  U,  U,  U,  U,
								     D,  B,  U,  0,  1,
								     B,  D,  U,  1,  0 };
 
int EQVTABLE[MULTIVALUE][MULTIVALUE] =  { 1,  0,  U,  B,  D,
								     0,  1,  U,  D,  B,
								     U,  U,  U,  U,  U,
								     B,  D,  U,  1,  0,
								     D,  B,  U,  0,  1 };

int INV[MULTIVALUE] = { 1,  0,  U,  B,  D };
End of logic_tbl.h
echo makefile 1>&2
cat >makefile <<'End of makefile'
#

CFLAGS = -g 

FILES = tpgmain.o input.o level.o sim.o podem.o test.o init_flist.o pfedfs.o display.o

atpg : $(FILES) 
	cc $(CFLAGS) $(FILES) -lm -o atpg

tpgmain.o : atpg.h miscell.h
input.o : atpg.h miscell.h
level.o : atpg.h miscell.h
sim.o : atpg.h miscell.h logic_tbl.h
podem.o : atpg.h miscell.h
init_flist.o : atpg.h miscell.h
pfedfs.o : atpg.h miscell.h
test.o : atpg.h miscell.h
display.o : atpg.h miscell.h
End of makefile
echo miscell.h 1>&2
cat >miscell.h <<'End of miscell.h'
/**********************************************************************/
/*           miscellaneous macro substitutions and declarations       */
/*                                                                    */
/*           Author: Tony Hi Keung Ma                                 */
/*           last update : 3/26/1986                                  */
/**********************************************************************/

#define ALLOC(num,type)    (type *)calloc(num,sizeof(type))
#define NIL(type)      ((type *)0)
#define MAYBE          2
#define TRUE           1
#define FALSE          0
#define REDUNDANT      3
#define STUCK0         0
#define STUCK1         1
#define ALL_ONE        0xffffffff
#define ALL_ZERO       0x00000000
#define MAX(A,B) ((A) > (B) ? (A) : (B))
#define MIN(A,B) ((A) < (B) ? (A) : (B))
#define ABS(A) ((A) < 0 ? -(A) : (A))

typedef struct FAULT *fptr;

struct FAULT {
    nptr node;            /* gate under test(NIL if PI/PO fault) */
    short io;             /* 0 = GI; 1 = GO */
	short index;          /* index for GI fault */
    short fault_type;     /* s-a-1 or s-a-0 fault */
    short detect;         /* detection flag */
    short test_tried;     /* flag to indicate test is being tried */
    short eqv_fault_num;  /* number of equivalent faults */
    fptr pnext;           /* pointer to the next element in the list */
    fptr pnext_undetect;  /* pointer to next undetected fault */
	short to_swlist;      /* index to the sort_wlist[] */ 
	int fault_no;         /* fault index */
};

fptr first_fault;         /* pointer to the first element of the fault list */

/* possible values for fault->faulty_net_type */
#define GI 0
#define GO 1
End of miscell.h
echo pfedfs.c 1>&2
cat >pfedfs.c <<'End of pfedfs.c'
/**********************************************************************/
/*           Parallel-Fault Event-Driven Fault Simulator              */
/*                                                                    */
/*           Author: Tony Hi Keung Ma                                 */
/*           last update : 4/11/1986                                  */
/**********************************************************************/

#include <stdio.h>
#include "global.h"
#include "miscell.h"


/*
 * routine to do the fault simulation 
 */

#define num_of_pattern 16

unsigned int Mask[16] = {0x00000003, 0x0000000c, 0x00000030, 0x000000c0,
					   0x00000300, 0x00000c00, 0x00003000, 0x0000c000,
                         0x00030000, 0x000c0000, 0x00300000, 0x00c00000,
					   0x03000000, 0x0c000000, 0x30000000, 0xc0000000,
					  };

unsigned int Unknown[16] =
				       {0x00000001, 0x00000004, 0x00000010, 0x00000040,
					   0x00000100, 0x00000400, 0x00001000, 0x00004000,
                         0x00010000, 0x00040000, 0x00100000, 0x00400000,
					   0x01000000, 0x04000000, 0x10000000, 0x40000000,
					  };

wptr first_faulty_wire;
extern int debug;

fptr
fault_sim(flist,num_of_current_detect)
fptr flist;
int *num_of_current_detect;
{
    register wptr w,faulty_wire,wtemp;
    register fptr f,simulated_fault_list[num_of_pattern],ftemp;
    int fault_type;
    register int i,j,k,start_wire_index,num_of_fault;
    int fault_sim_evaluate();
    wptr get_faulty_wire();
    int sim();
    static int test_no = 0;

    test_no++;
    num_of_fault = 0;
    *num_of_current_detect = 0;
    start_wire_index = 10000;
    first_faulty_wire = NULL;
    for (i = 0; i < ncktwire; i++) {
	      if (i < ncktin) sort_wlist[i]->flag |= CHANGED;
		 else sort_wlist[i]->value = 2;
    }
    sim(); /* do a fault-free simulation */
    if (debug) display_io();
    for (i = 0; i < ncktwire; i++) {
		 switch (sort_wlist[i]->value) {
			case 1: sort_wlist[i]->wire_value1 = ALL_ONE;
			        sort_wlist[i]->wire_value2 = ALL_ONE; break;
			case 2: sort_wlist[i]->wire_value1 = 0x55555555;
			        sort_wlist[i]->wire_value2 = 0x55555555; break;
			case 0: sort_wlist[i]->wire_value1 = ALL_ZERO;
			        sort_wlist[i]->wire_value2 = ALL_ZERO; break;
	      }
		 sort_wlist[i]->pnext = NULL;
    }

    for (f = flist; f; f = f->pnext_undetect) {
        if (f->detect == REDUNDANT) continue;
		 if (f->fault_type != sort_wlist[f->to_swlist]->value) {
            if ((f->node->type == OUTPUT) || (f->io == GO && sort_wlist[f->to_swlist]->flag & OUTPUT)) {
			    f->detect = TRUE;
			}
            else {
                if (f->io == GO) {
				   if (!(sort_wlist[f->to_swlist]->flag & FAULTY)) {
				       sort_wlist[f->to_swlist]->pnext = first_faulty_wire;
			            first_faulty_wire = sort_wlist[f->to_swlist];
				       first_faulty_wire->flag |= FAULTY;
				   }
			        simulated_fault_list[num_of_fault] = f;
				   inject_fault_value(sort_wlist[f->to_swlist],num_of_fault,f->fault_type);
				   sort_wlist[f->to_swlist]->flag |= FAULT_INJECTED;
				   for (k = 0; k < sort_wlist[f->to_swlist]->nout; k++) {
				       sort_wlist[f->to_swlist]->onode[k]->owire[0]->flag |= SCHEDULED;
				   }
				   num_of_fault++;
				   start_wire_index = MIN(start_wire_index,f->to_swlist);
			    }
                else {
			        if (faulty_wire = get_faulty_wire(f,&fault_type)) {
					  if (faulty_wire->flag & OUTPUT) f->detect = TRUE;
					  else {
						 if (!(faulty_wire->flag & FAULTY)) {
					          faulty_wire->pnext = first_faulty_wire;
					          first_faulty_wire = faulty_wire;
				               first_faulty_wire->flag |= FAULTY;
						 }
					      simulated_fault_list[num_of_fault] = f;
					      inject_fault_value(faulty_wire,num_of_fault,fault_type);
				           faulty_wire->flag |= FAULT_INJECTED;
				           for (k = 0; k < faulty_wire->nout; k++) {
				               faulty_wire->onode[k]->owire[0]->flag |= SCHEDULED;
				           }
				           num_of_fault++;
				           start_wire_index = MIN(start_wire_index,f->to_swlist);
					  }
				   }
                }
			}
        }
        /*
        * fault simulation starts here
        */
        if ((num_of_fault == num_of_pattern) || !(f->pnext_undetect)) {
			for (i = start_wire_index; i < ncktwire; i++) {
                if (sort_wlist[i]->flag & SCHEDULED) {
				   sort_wlist[i]->flag &= ~SCHEDULED;
			        fault_sim_evaluate(sort_wlist[i]);
                }
	          } /* event evaluations end here */

            /* check detection and reset wires' faulty values
            * back to fault-free values
            */
            for (w = first_faulty_wire; w; w = wtemp) {
                wtemp = w->pnext;
                w->pnext = NIL(struct WIRE);
			    w->flag &= ~FAULTY;
			    w->flag &= ~FAULT_INJECTED;
			    w->fault_flag &= ALL_ZERO;
			    if (w->flag & OUTPUT) {
				   for (i = 0; i < num_of_fault; i++) {
					  if (!(simulated_fault_list[i]->detect)) {
					      if ((w->wire_value2 & Mask[i]) ^ (w->wire_value1 & Mask[i])) {
					          if (((w->wire_value2 & Mask[i]) ^ Unknown[i]) && ((w->wire_value1 & Mask[i]) ^ Unknown[i])) {
				                   simulated_fault_list[i]->detect = TRUE;
							}
				           }
                        }
				   }
			    }
                w->wire_value2 = w->wire_value1;
            }
            /*check();
		     check2();*/
			num_of_fault = 0;
            start_wire_index = 10000;
            first_faulty_wire = NULL;
        }
    }
    while(flist) {
		 if (flist->detect == TRUE) {
			(*num_of_current_detect) += flist->eqv_fault_num;
	          f = flist->pnext_undetect;
	          flist->pnext_undetect = NULL;
		     flist = f;
	      }
		 else break;
    }

    if (flist) {
        for (f = flist; f->pnext_undetect; f = ftemp) {
	          if (f->pnext_undetect->detect == TRUE) { 
			    (*num_of_current_detect) += f->pnext_undetect->eqv_fault_num;
			    f->pnext_undetect = f->pnext_undetect->pnext_undetect;
		         ftemp = f;
            }
			else  ftemp = f->pnext_undetect;
	      }
    }
    return(flist);
}/* end of fault_sim */

check2()
{
    register int i;

    for (i = 0; i < ncktwire; i++) {
	      if (sort_wlist[i]->flag & (FAULTY | FAULT_INJECTED | SCHEDULED) || (sort_wlist[i]->fault_flag)){
			fprintf(stdout,"something is fishy(check2)...\n");
        }
    }
    return;
}/* end of check2 */

check()
{
    register int i;

    for (i = 0; i < ncktwire; i++) {
	      if (sort_wlist[i]->wire_value1 != sort_wlist[i]->wire_value2) {
			fprintf(stdout,"something is fishy...\n");
        }
    }
    return;
}/* end of check */

fault_sim_evaluate(w)
wptr w;
{
    unsigned int new_value;
    register nptr n;
    register int i;
    int combine();
    unsigned int PINV(),PEXOR(),PEQUIV();

    /*if (w->flag & INPUT) return;*/
    n = w->inode[0];
    switch(n->type) {
		 case AND:
        case BUF:
        case NAND:
	          new_value = ALL_ONE;
            for (i = 0; i < n->nin; i++) {
		         new_value &= n->iwire[i]->wire_value2;
            }
            if (n->type == NAND) {
			    new_value = PINV(new_value);
            }
            break;
        case OR:
        case NOR:
            new_value = ALL_ZERO;
            for (i = 0; i < n->nin; i++) {
		         new_value |= n->iwire[i]->wire_value2;
            }
            if (n->type == NOR) {
			    new_value = PINV(new_value);
            }
            break;
        case NOT:
	          new_value = PINV(n->iwire[0]->wire_value2);
			break;
        case XOR:
            new_value = PEXOR(n->iwire[0]->wire_value2, n->iwire[1]->wire_value2);
			break;
        case EQV:
            new_value = PEQUIV(n->iwire[0]->wire_value2, n->iwire[1]->wire_value2);
			break;
    }
    if (w->wire_value1 != new_value) {
	      if (w->flag & FAULT_INJECTED) {
            combine(w,&new_value);
        }
        w->wire_value2 = new_value;
		 if (!(w->flag & FAULTY)) {
		     w->flag |= FAULTY;
		     w->pnext = first_faulty_wire;
		     first_faulty_wire = w;
        }
		 for (i = 0; i < w->nout; i++) {
			if (w->onode[i]->type != OUTPUT) {
			    w->onode[i]->owire[0]->flag |= SCHEDULED;
			}
        }
    }
    return;
}/* end of fault_sim_evaluate */


wptr
get_faulty_wire(f,fault_type)
fptr f;
int *fault_type;
{
    register int i,is_faulty;

    is_faulty = TRUE;
    switch(f->node->type) {
	      case NOT:
	      case BUF: fprintf(stdout,"something is fishy(get_faulty_net)...\n"); break;
		 case AND:
            for (i = 0; i < f->node->nin; i++) {
			    if (f->node->iwire[i] != sort_wlist[f->to_swlist]) {
				   if (f->node->iwire[i]->value != 1) is_faulty = FALSE;
			    }
		     }
			*fault_type = STUCK1;
            break;
        case NAND:
            for (i = 0; i < f->node->nin; i++) {
			    if (f->node->iwire[i] != sort_wlist[f->to_swlist]) {
				   if (f->node->iwire[i]->value != 1) is_faulty = FALSE;
			    }
		     }
			*fault_type = STUCK0;
            break;
        case   OR:
            for (i = 0; i < f->node->nin; i++) {
			    if (f->node->iwire[i] != sort_wlist[f->to_swlist]) {
				   if (f->node->iwire[i]->value != 0) is_faulty = FALSE;
			    }
		     }
			*fault_type = STUCK0;
            break;
        case  NOR:
            for (i = 0; i < f->node->nin; i++) {
			    if (f->node->iwire[i] != sort_wlist[f->to_swlist]) {
				   if (f->node->iwire[i]->value != 0) is_faulty = FALSE;
			    }
		     }
			*fault_type = STUCK1;
            break;
        case XOR:
            for (i = 0; i < f->node->nin; i++) {
			    if (f->node->iwire[i] != sort_wlist[f->to_swlist]) {
				   if (f->node->iwire[i]->value == 0) *fault_type = f->fault_type ;
				   else *fault_type = f->fault_type ^ 1;
			    }
		     }
            break;
        case EQV:
            for (i = 0; i < f->node->nin; i++) {
			    if (f->node->iwire[i] != sort_wlist[f->to_swlist]) {
				   if (f->node->iwire[i]->value == 0) *fault_type = f->fault_type ^ 1;
				   else *fault_type = f->fault_type;
			    }
		     }
            break;
    }
    if (is_faulty) return(f->node->owire[0]);
    return(NULL);
}/* end of get_faulty_wire */


inject_fault_value(faulty_wire,bit_position,fault)
wptr faulty_wire;
int bit_position,fault;
{
    if (fault) faulty_wire->wire_value2 |= Mask[bit_position];
    else faulty_wire->wire_value2 &= ~Mask[bit_position];
    faulty_wire->fault_flag |= Mask[bit_position];
    return;
}/* end of inject_fault_value */

combine(w,new_value)
wptr w;
unsigned int *new_value;
{
    register int i;

    for (i = 0; i < num_of_pattern; i++) {
	      if (w->fault_flag & Mask[i]) {
		     *new_value &= ~Mask[i];
		     *new_value |= (w->wire_value2 & Mask[i]);
        }
    }
    return;
} /* end of combine */


unsigned int
PINV(value)
unsigned int value;
{
    return((((value & 0x55555555) << 1) ^ 0xaaaaaaaa) | (((value & 0xaaaaaaaa) >> 1) ^ 0x55555555));
}/* end of PINV */


unsigned int
PEXOR(value1,value2)
unsigned int value1,value2;
{
    unsigned int PINV();

    return((value1 & PINV(value2)) | (PINV(value1) & value2));
}/* end of PEXOR */

unsigned int
PEQUIV(value1,value2)
unsigned int value1,value2;
{
    unsigned int PINV();

    return((value1 | PINV(value2)) & (PINV(value1) | value2));
}/* end of PEQUIV */


End of pfedfs.c
echo pi_reach.c 1>&2
cat >pi_reach.c <<'End of pi_reach.c'

/**********************************************************************/
/*           This is the routine to set up the                        */
/*           pi_reach array of each wire                              */
/*                                                                    */
/*           Author: Tony Hi-Keung Ma                                 */
/*           last update : 5/24/1986                                  */
/**********************************************************************/


#include <stdio.h>
#include "global.h"
#include "miscell.h"


setup_pi_reach()
{
    register wptr w;
    register int i;

    for (i = 0; i < ncktwire; i++) {
        sort_wlist[i]->pi_reach = ALLOC(ncktin,short);
    }
    for (i = 0; i < ncktin; i++) {
        increment_pi_reach(cktin[i],i);
    }
    return;
}/* end of setup_pi_reach */


increment_pi_reach(wire,pi)
wptr wire;
int pi;
{
    register int i;

    (wire->pi_reach[pi])++;
    for (i = 0; i < wire->nout; i++) {
        if (wire->onode[i]->nout) {
            increment_pi_reach(wire->onode[i]->owire[0],pi);
        }
    }
    return;
}/* end of increment_pi_reach */
End of pi_reach.c
echo podem.c 1>&2
cat >podem.c <<'End of podem.c'
/**********************************************************************/
/*           This is the podem test pattern generator for atpg        */
/*                                                                    */
/*           Author: Hi-Keung Tony Ma                                 */
/*           last update : 07/11/1988                                 */
/**********************************************************************/

#include <stdio.h>
#include "global.h"
#include "miscell.h"

#define U  2
#define D  3
#define B  4
#define CONFLICT 2

extern int backtrack_limit;
extern int total_attempt_num;
int no_of_backtracks;
int find_test;
int no_test;
int unique_imply;

podem(fault, current_backtracks)
fptr fault;
int *current_backtracks;
{
    register int i,j;
    register nptr n;
    register wptr wpi,decision_tree,wtemp,wfault;
    wptr test_possible();
    wptr fault_evaluate();
    long random();
    int set_uniquely_implied_value();
	int attempt_num = 0;
	void display_fault();

    /* initialize all circuit wires to unknown */
    for (i = 0; i < ncktwire; i++) {
        sort_wlist[i]->value = U;
    }
    no_of_backtracks = 0;
    find_test = FALSE;
    no_test = FALSE;
    decision_tree = NIL(struct WIRE);
    wfault = NIL(struct WIRE);
    mark_propagate_tree(fault->node);
    switch (set_uniquely_implied_value(fault)) {
        case TRUE:
            sim();
            if (wfault = fault_evaluate(fault)) forward_imply(wfault);
            if (check_test()) find_test = TRUE;
            break;
        case CONFLICT:
            no_test = TRUE;
            break;
        case FALSE: break;
    }

    while ((no_of_backtracks < backtrack_limit) && !no_test &&
        !(find_test && (attempt_num == total_attempt_num))) {
        if (wpi = test_possible(fault)) {
            wpi->flag |= CHANGED;
            wpi->pnext = decision_tree;
            decision_tree = wpi;
        }
        else {
            while (decision_tree && !wpi) {
                /*if (decision_tree->flag & FIXED) break;*/
                if (decision_tree->flag & ALL_ASSIGNED) {
                    decision_tree->flag &= ~ALL_ASSIGNED;
                    decision_tree->value = U;
                    decision_tree->flag |= CHANGED;
                    wtemp = decision_tree;
                    decision_tree = decision_tree->pnext;
                    wtemp->pnext = NIL(struct WIRE);
                }
                else {
                    decision_tree->value = decision_tree->value ^ 1;
                    decision_tree->flag |= CHANGED;
                    decision_tree->flag |= ALL_ASSIGNED;
                    no_of_backtracks++;
                    wpi = decision_tree;
                }
            }
            if (!wpi) no_test = TRUE;
        }
again:  if (wpi) {
            sim();
            if (wfault = fault_evaluate(fault)) forward_imply(wfault);
            /*display_line(fault);*/
            if (check_test()) {
				find_test = TRUE;
				if (total_attempt_num > 1) {
					if (attempt_num == 0) {
						display_fault(fault);
					}
					display_io();
				}
				attempt_num++;
				if (total_attempt_num > attempt_num) {
					wpi = NIL(struct WIRE);
            		while (decision_tree && !wpi) {
                		/*if (decision_tree->flag & FIXED) break;*/
                		if (decision_tree->flag & ALL_ASSIGNED) {
                    		decision_tree->flag &= ~ALL_ASSIGNED;
                    		decision_tree->value = U;
                    		decision_tree->flag |= CHANGED;
                    		wtemp = decision_tree;
                    		decision_tree = decision_tree->pnext;
                    		wtemp->pnext = NIL(struct WIRE);
                		}
                		else {
                    		decision_tree->value = decision_tree->value ^ 1;
                    		decision_tree->flag |= CHANGED;
                    		decision_tree->flag |= ALL_ASSIGNED;
                    		no_of_backtracks++;
                    		wpi = decision_tree;
                		}
            		}
            		if (!wpi) no_test = TRUE;
					goto again;
				}
			}
        }
    }
    for (wpi = decision_tree; wpi; wpi = wtemp) {
         wtemp = wpi->pnext;
         wpi->pnext = NIL(struct WIRE);
         wpi->flag &= ~ALL_ASSIGNED;
         /*wpi->flag &= ~FIXED;*/
    }
    *current_backtracks = no_of_backtracks;
    unmark_propagate_tree(fault->node);
    if (find_test) {
        /*display_io();*/
		if (total_attempt_num == 1) {
        	for (i = 0; i < ncktin; i++) {
            	switch (cktin[i]->value) {
                	case 0:
                	case 1: break;
                	case D: cktin[i]->value = 1; break;
                	case B: cktin[i]->value = 0; break;
                	case U: cktin[i]->value = random()&01; break;
                	/*case U: if (cktin[i]->flag & PSTATE) break;
                    	cktin[i]->value = random()&01;*/

            	}
        	}
        	/********** added to simulate test vector ***********/
        	/* initialize all circuit wires to unknown */
        	/*for (i = ncktin; i < ncktwire; i++) {
            	sort_wlist[i]->value = U;
        	}
        	for (i = 0; i < ncktin; i++) {
            	cktin[i]->flag |= CHANGED;
        	}
        	sim();*/
			/****************************************************/
        	display_io();
		}
		else fprintf(stdout, "\n");
        return(TRUE);
    }
    else if (no_test) {
        /*fprintf(stdout,"redundant fault...\n");*/
        return(FALSE);
    }
    else {
        /*fprintf(stdout,"test aborted due to backtrack limit...\n");*/
        return(MAYBE);
    }
}/* end of podem */


wptr
fault_evaluate(fault)
fptr fault;
{
    register int i;
    register int temp1;
    register wptr w;

    if (fault->io) {
        w = fault->node->owire[0];
        if (w->value == U) return(NULL);
        if (fault->fault_type == 0 && w->value == 1) w->value = D;
        if (fault->fault_type == 1 && w->value == 0) w->value = B;
        return(w);
    }
    else {
        w = fault->node->iwire[fault->index];
        if (w->value == U) return(NULL);
        else {
            temp1 = w->value;
            if (fault->fault_type == 0 && w->value == 1) w->value = D;
            if (fault->fault_type == 1 && w->value == 0) w->value = B;
            if (fault->node->type == OUTPUT) return(NULL);
            evaluate(fault->node);
            w->value = temp1;
            if (fault->node->owire[0]->flag & CHANGED) {
                fault->node->owire[0]->flag &= ~CHANGED;
                return (fault->node->owire[0]);
            }
            else return(NULL);
        }
    }
}/* end of fault_evaluate */


forward_imply(w)
wptr w;
{
    register int i;

    for (i = 0; i < w->nout; i++) {
        if (w->onode[i]->type != OUTPUT) {
            evaluate(w->onode[i]);
            if (w->onode[i]->owire[0]->flag & CHANGED)
                forward_imply(w->onode[i]->owire[0]);
            w->onode[i]->owire[0]->flag &= ~CHANGED;
        }
    }
    return;
}/* end of forward_imply */


wptr
test_possible(fault)
fptr fault;
{
    register nptr n;
    register wptr object_wire;
    register int object_level;
    nptr find_propagate_gate();
    wptr find_pi_assignment();
    int trace_unknown_path();

    if (fault->node->type != OUTPUT) {
        if (fault->node->owire[0]->value ^ U) {
            if (!((fault->node->owire[0]->value == B) ||
                (fault->node->owire[0]->value == D))) return(NULL);
            if (!(n = find_propagate_gate(fault->node->owire[0]->level)))
                return(NULL);
            switch(n->type) {
                case  AND:
                case  NOR: object_level = 1; break;
                case NAND:
                case   OR: object_level = 0; break;
                default:
                    fprintf(stderr,"Internal Error(1st bp. in test_possible)!\n");
                    exit(-1);
            }
            object_wire = n->owire[0];
        }
        else {
            if (!(trace_unknown_path(fault->node->owire[0])))
                return(NULL);
            if (fault->io) {
                if (fault->fault_type) object_level = 0;
                else object_level = 1;
                object_wire = fault->node->owire[0];
            }
            else {
                if (fault->node->iwire[fault->index]->value  ^ U) {
                    switch (fault->node->type) {
                        case  AND:
                        case  NOR: object_level = 1; break;
                        case NAND:
                        case   OR: object_level = 0; break;
                        default:
                            fprintf(stderr,"Internal Error(2nd bp. in test_possible)!\n");
                            exit(-1);
                    }
                    object_wire = fault->node->owire[0];
                }
                else {
                    if (fault->fault_type) object_level = 0;
                    else object_level = 1;
                    object_wire = fault->node->iwire[fault->index];
                }
            }
        }
    }
    else {
        if (fault->node->iwire[0]->value == U) {
            if (fault->fault_type) object_level = 0;
            else object_level = 1;
            object_wire = fault->node->iwire[0];
        }
        else {
            fprintf(stderr,"Internal Error(1st bp. in test_possible)!\n");
            exit(-1);
        }
    }
    return(find_pi_assignment(object_wire,object_level));
}/* end of test_possible */



wptr
find_pi_assignment(object_wire,object_level)
wptr object_wire;
int object_level;
{
    register wptr new_object_wire;
    register int new_object_level;
    wptr find_hardest_control(),find_easiest_control();

    if (object_wire->flag & INPUT) {
    object_wire->value = object_level;
    return(object_wire);
    }
    else {
        switch(object_wire->inode[0]->type) {
        case   OR:
        case NAND:
        if (object_level) new_object_wire = find_easiest_control(object_wire->inode[0]);
        else new_object_wire = find_hardest_control(object_wire->inode[0]);
        /*if (object_level) new_object_wire = find_hardest_control(object_wire->inode[0]);
            else new_object_wire = find_easiest_control(object_wire->inode[0]);*/
                break;
        case  NOR:
        case  AND:
        if (object_level) new_object_wire = find_hardest_control(object_wire->inode[0]);
        else new_object_wire = find_easiest_control(object_wire->inode[0]);
        /*if (object_level) new_object_wire = find_easiest_control(object_wire->inode[0]);
        else new_object_wire = find_hardest_control(object_wire->inode[0]);*/
                break;
        case  NOT:
        case  BUF:
        new_object_wire = object_wire->inode[0]->iwire[0];
        break;
        }
    switch (object_wire->inode[0]->type) {
        case  BUF:
        case  AND:
        case   OR: new_object_level = object_level; break;
        case  NOT:
        case  NOR:
        case NAND: new_object_level = object_level ^ 1; break;
        }
        if (new_object_wire) return(find_pi_assignment(new_object_wire,new_object_level));
        else return(NULL);
    }
}/* end of find_pi_assignment */


wptr
find_hardest_control(n)
nptr n;
{
    register int i;

    for (i = n->nin - 1; i >= 0; i--) {
        if (n->iwire[i]->value  == U) return(n->iwire[i]);
    }
    return(NULL);
}/* end of find_hardest_control */


wptr
find_easiest_control(n)
nptr n;
{
    register int i;

    for (i = 0; i < n->nin; i++) {
        if (n->iwire[i]->value  == U) return(n->iwire[i]);
    }
    return(NULL);
}/* end of find_easiest_control */


nptr
find_propagate_gate(level)
int level;
{
    register int i,j;
    register wptr w;
    int trace_unknown_path();

    for (i = ncktwire - 1; i >= 0; i--) {
        if (sort_wlist[i]->level == level) return(NULL);
        if ((sort_wlist[i]->value == U) &&
            (sort_wlist[i]->inode[0]->flag & MARKED)) {
            for (j = 0; j < sort_wlist[i]->inode[0]->nin; j++) {
                w = sort_wlist[i]->inode[0]->iwire[j];
                if ((w->value == D) || (w->value == B)) {
                    if (trace_unknown_path(sort_wlist[i]))
                        return(sort_wlist[i]->inode[0]);
                   break;
                }
            }
        }
    }
}/* end of find_propagate_gate */


trace_unknown_path(w)
wptr w;
{
    register int i;
    register wptr wtemp;

    if (w->flag & OUTPUT) return(TRUE);
    for (i = 0; i < w->nout; i++) {
        wtemp = w->onode[i]->owire[0];
        if (wtemp->value == U) {
            if(trace_unknown_path(wtemp)) return(TRUE);
        }
    }
    return(FALSE);
}/* end of trace_unknown_path */


check_test()
{
    register int i,is_test;

    is_test = FALSE;
    for (i = 0; i < ncktout; i++) {
        if ((cktout[i]->value == D) || (cktout[i]->value == B)) {
            is_test = TRUE;
        }
        if (is_test == TRUE) break;
    }
    return(is_test);
}/* end of check_test */


mark_propagate_tree(n)
nptr n;
{
    register int i,j;

    if (n->flag & MARKED) return;
    n->flag |= MARKED;
    for (i = 0; i < n->nout; i++) {
        for (j = 0; j < n->owire[i]->nout; j++) {
            mark_propagate_tree(n->owire[i]->onode[j]);
        }
    }
    return;
}/* end of mark_propagate_tree */


unmark_propagate_tree(n)
nptr n;
{
    register int i,j;

    if (n->flag & MARKED) {
        n->flag &= ~MARKED;
        for (i = 0; i < n->nout; i++) {
            for (j = 0; j < n->owire[i]->nout; j++) {
                unmark_propagate_tree(n->owire[i]->onode[j]);
            }
        }
    }
    return;
}/* end of unmark_propagate_tree */


set_uniquely_implied_value(fault)
fptr fault;
{
    register wptr w;
    register int pi_is_reach = FALSE;
    register int i;

    if (fault->io) w = fault->node->owire[0];
    else {
        w = fault->node->iwire[fault->index];
        switch (fault->node->type) {
            case NOT:
            case BUF:
                fprintf(stderr,"Internal Error(1st bp. in set_uniquely_implied_value)!\n");
                exit(-1);
            case AND:
            case NAND:
                 for (i = 0; i < fault->node->nin; i++) {
                     if (fault->node->iwire[i] != w) {
                         switch (backward_imply(fault->node->iwire[i],1)) {
                             case TRUE: pi_is_reach = TRUE; break;
                             case CONFLICT: return(CONFLICT); break;
                             case FALSE: break;
                         }
                     }
                 }
                 break;
            case OR:
            case NOR:
                 for (i = 0; i < fault->node->nin; i++) {
                     if (fault->node->iwire[i] != w) {
                         switch (backward_imply(fault->node->iwire[i],0)) {
                             case TRUE: pi_is_reach = TRUE; break;
                             case CONFLICT: return(CONFLICT); break;
                             case FALSE: break;
                         }
                     }
                 }
                 break;
        }
    }
    switch (backward_imply(w,(fault->fault_type ^ 1))) {
        case TRUE: pi_is_reach = TRUE; break;
        case CONFLICT: return(CONFLICT); break;
        case FALSE: break;
    }
    return(pi_is_reach);
}/* end of set_uniquely_implied_value */


backward_imply(current_wire,logic_level)
wptr current_wire;
int logic_level;
{
    register int pi_is_reach = FALSE;
    register int i;

    if (current_wire->flag & INPUT) {
        if (current_wire->value != U &&
            current_wire->value != logic_level) {
            return(CONFLICT);
        }
        current_wire->value = logic_level;
        /*current_wire->flag |= FIXED;*/
        current_wire->flag |= CHANGED;
        return(TRUE);
    }
    else {
        switch (current_wire->inode[0]->type) {
            case NOT:
                switch (backward_imply(current_wire->inode[0]->iwire[0],
                    (logic_level ^ 1))) {
                    case TRUE: pi_is_reach = TRUE; break;
                    case CONFLICT: return(CONFLICT); break;
                    case FALSE: break;
                }
                break;
            case NAND:
                if (!logic_level) {
                    for (i = 0; i < current_wire->inode[0]->nin; i++) {
                        switch (backward_imply(current_wire->inode[0]->iwire[i],1)) {
                            case TRUE: pi_is_reach = TRUE; break;
                            case CONFLICT: return(CONFLICT); break;
                            case FALSE: break;
                        }
                    }
                }
                break;
            case AND:
                if (logic_level) {
                    for (i = 0; i < current_wire->inode[0]->nin; i++) {
                        switch (backward_imply(current_wire->inode[0]->iwire[i],1)) {
                            case TRUE: pi_is_reach = TRUE; break;
                            case CONFLICT: return(CONFLICT); break;
                            case FALSE: break;
                        }
                    }
                }
                break;
            case OR:
                if (!logic_level) {
                    for (i = 0; i < current_wire->inode[0]->nin; i++) {
                        switch (backward_imply(current_wire->inode[0]->iwire[i],0)) {
                            case TRUE: pi_is_reach = TRUE; break;
                            case CONFLICT: return(CONFLICT); break;
                            case FALSE: break;
                        }
                    }
                }
                break;
            case NOR:
                if (logic_level) {
                    for (i = 0; i < current_wire->inode[0]->nin; i++) {
                        switch (backward_imply(current_wire->inode[0]->iwire[i],0)) {
                            case TRUE: pi_is_reach = TRUE; break;
                            case CONFLICT: return(CONFLICT); break;
                            case FALSE: break;
                        }
                    }
                }
                break;
            case BUF:
                switch (backward_imply(current_wire->inode[0]->iwire[0],logic_level)) {
                    case TRUE: pi_is_reach = TRUE; break;
                    case CONFLICT: return(CONFLICT); break;
                    case FALSE: break;
                }
                break;
        }
        return(pi_is_reach);
    }
}/* end of backward_imply */
End of podem.c
echo sim.c 1>&2
cat >sim.c <<'End of sim.c'
/**********************************************************************/
/*           This is the logic simulator for atpg                     */
/*                                                                    */
/*           Author: Hi-Keung TonyMa                                 */
/*           last update : 09/25/1987                                 */
/**********************************************************************/

#include <stdio.h>
#include "global.h"
#include "miscell.h"
#include "logic_tbl.h"


/*
*   sim
*
*   RETURNS
*       no value is returned
*
*   SIDE-EFFECTS
*       changes the logic values inside some wires' data structures
*
*   perform the logic simulation 
*   event-driven technique coupled with levelling mechanism is employed
*/

void
sim()
{
    int i, j;
    int evaluate();

    for (i = 0; i < ncktin; i++) {
	    if (sort_wlist[i]->flag & CHANGED) {
			sort_wlist[i]->flag &= ~CHANGED;
			for (j = 0; j < sort_wlist[i]->nout; j++) {
			    if (sort_wlist[i]->onode[j]->nout) {
			        sort_wlist[i]->onode[j]->owire[0]->flag
						|= SCHEDULED;
			    }
            }
        }
    }

    for (i = ncktin; i < ncktwire; i++) {
	    if (sort_wlist[i]->flag & SCHEDULED) {
			sort_wlist[i]->flag &= ~SCHEDULED;
			evaluate(sort_wlist[i]->inode[0]);
			if (sort_wlist[i]->flag & CHANGED) {
			    sort_wlist[i]->flag &= ~CHANGED;
			    for (j = 0; j < sort_wlist[i]->nout; j++) {
				if (sort_wlist[i]->onode[j]->nout) {
			        sort_wlist[i]->onode[j]->owire[0]->flag
						|= SCHEDULED;
				   }
			    }
            }
        }
    }
    return;
}/* end of sim */

evaluate(n)
nptr n;
{
    unsigned int old_value, new_value;
    int i;

	old_value = n->owire[0]->value;
    switch(n->type) {
		case AND:
        case BUF:
        case NAND:
	        new_value = 1;
			for (i = 0; i < n->nin; i++) {
			    new_value = ANDTABLE[n->iwire[i]->value][new_value];
            }
            if (n->type == NAND) {
			    new_value = INV[new_value];
            }
            break;
        case OR:
        case NOR:
            new_value = 0;
            for (i = 0; i < n->nin; i++) {
	            new_value = ORTABLE[n->iwire[i]->value][new_value];
            }
            if (n->type == NOR) {
			    new_value = INV[new_value];
            }
            break;
        case NOT:
	        new_value = INV[n->iwire[0]->value];
			break;
        case XOR:
            new_value = XORTABLE[n->iwire[0]->value][n->iwire[1]->value];
			break;
        case EQV:
            new_value = INV[(XORTABLE[n->iwire[0]->value][n->iwire[1]->value])];
			break;
    }
    if (old_value != new_value) {
	    n->owire[0]->flag |= CHANGED;
		n->owire[0]->value = new_value;
    }
    return;
}/* end of evaluate */


/*
* unpack an unsigned integer and return a particular bit
*/
char
unpack(value,bit_no)
unsigned int value;
int bit_no;
{
    register int bit_value;

    bit_value = (value >> (bit_no - 1)*2) & 3;
    switch(bit_value) {
        case 0 : return('0');break;
        case 1 : return('x');break;
        case 3 : return('1');break;
    }
} /* end of unpack */
End of sim.c
echo test.c 1>&2
cat >test.c <<'End of test.c'
#include <stdio.h>
#include "global.h"
#include "miscell.h"

extern int total_attempt_num;

test()
{
    register fptr undetect_fault;
    register fptr f,fault_under_test, ftemp;
    fptr fault_sim();
    int podem();
    int current_detect_num,total_detect_num, i;
    int total_no_of_backtracks = 0;
    int current_backtracks;
    register int no_of_aborted_faults = 0, no_of_redundant_faults = 0;
    register int no_of_calls = 0;
    int display_undetect();

    in_vector_no = 0;
    total_detect_num = 0;
    undetect_fault = first_fault;
    fault_under_test = first_fault;

	/*for (i = 0; i < 178; i++) {
		fault_under_test = fault_under_test->pnext_undetect;
	}*/

    while(fault_under_test) {
        switch(podem(fault_under_test,&current_backtracks)) {
            case TRUE:
				if (total_attempt_num == 1) {
	        		undetect_fault = fault_sim(undetect_fault,&current_detect_num);
	        		total_detect_num += current_detect_num;
	        		/*fprintf(stdout,"tdn = %d ; cdn = %d\n",total_detect_num,current_detect_num);
	        		fprintf(stdout,"\n");*/
				}
				else {
					fault_under_test->detect = TRUE;
					for (f = undetect_fault; f; f = f->pnext_undetect) {
						if (f == fault_under_test) {
							if (f == undetect_fault)
								undetect_fault = undetect_fault->pnext_undetect;
							else {
								ftemp->pnext_undetect = f->pnext_undetect;
							}
							break;
						}
						ftemp = f;
					}
				}
				in_vector_no++;
				break;
	    	case FALSE:
                fault_under_test->detect = REDUNDANT;
	        	no_of_redundant_faults++;
				break;
            case MAYBE:
				no_of_aborted_faults++;
				break;
		}
		fault_under_test->test_tried = TRUE;
		fault_under_test = NULL;
		for (f = undetect_fault; f; f = f->pnext_undetect) {
	    	if (!f->test_tried) {
				fault_under_test = f;
				break;
	    	}
        }
		total_no_of_backtracks += current_backtracks;
        no_of_calls++;
    }
    display_undetect(undetect_fault);
    fprintf(stdout,"\n");
    fprintf(stdout,"#number of aborted faults = %d\n",no_of_aborted_faults);
    fprintf(stdout,"\n");
    fprintf(stdout,"#number of redundant faults = %d\n",no_of_redundant_faults);
    fprintf(stdout,"\n");
    fprintf(stdout,"#number of calling podem1 = %d\n",no_of_calls);
    fprintf(stdout,"\n");
    fprintf(stdout,"#total number of backtracks = %d\n",total_no_of_backtracks);
    return;
}/* end of test */
End of test.c
echo tpgmain.c 1>&2
cat >tpgmain.c <<'End of tpgmain.c'

#define MAIN

#include <stdio.h>
#include "global.h"
#include "miscell.h"

extern char *filename;
int backtrack_limit = 50;       /* default value */
int total_attempt_num = 1;      /* default value */

main(argc,argv)
int argc;
char *argv[];
{
    FILE *in;
	void level_circuit(), rearrange_gate_inputs(), input();
    char inpFile[200];
    int i, j;

    timer(stdout,"START", filename);

    strcpy(inpFile, "xxxx");
    i = 1;
    while(i< argc) {
      if (strcmp(argv[i],"-anum") == 0) {
        total_attempt_num = atoi(argv[i+1]);
        i+=2;
      }
      else if (strcmp(argv[i],"-bt") == 0) {
        backtrack_limit = atoi(argv[i+1]);
        i+=2;
      }
      else if (argv[i][0] == '-') {
        j = 1;
        while (argv[i][j] != '\0') {
          if (argv[i][j] == 'd') {
            j++ ;
          }
          else {
            fprintf(stderr, "atpg: unknown option\n");
            usage();
          }
        }
        i++ ;
      }
      else {
        (void)strcpy(inpFile,argv[i]);
        i++ ;
      }
    }

    if (strcmp(inpFile, "xxxx") == 0)
      usage();
    input(inpFile);

    timer(stdout,"for reading in circuit",filename);
    level_circuit();
    timer(stdout,"for levelling circuit",filename);
	rearrange_gate_inputs();
	timer(stdout,"for rearranging gate inputs",filename);
    create_dummy_gate();
    timer(stdout,"for creating dummy nodes",filename);
    /*setup_pi_reach();
    timer(stdout,"for setting up pi_reach",filename);*/
    generate_fault_list();
    timer(stdout,"for generating fault list",filename);
    test();
    compute_fault_coverage();
    timer(stdout,"for test pattern generation",filename);
    exit(0);
}

usage()
{

   fprintf(stderr, "usage: atpg [options] infile\n");
   fprintf(stderr, "Options\n");
   fprintf(stderr, "      -anum <num>: <num> specifies number of vectors per fault\n");
   fprintf(stderr, "      -bt <num>: <num> specifies number of backtracks\n");
   exit(-1);

} /* end of usage() */
End of tpgmain.c

